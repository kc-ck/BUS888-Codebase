# -*- coding: utf-8 -*-
"""SimpleANNPrediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Br1_WRR6cfvB7GUYHtsEms4H2SETYCtZ

#**Simple ANN (Art. Neural Net) Example - Stock Price Prediction**

C Kaligotla

### Loading Libraries
"""

import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense
import matplotlib.pyplot as plt

"""### Constants and Inputs"""

# Constants
STOCK_SYMBOL = "GOOG"
START_DATE = '2024-07-11'
END_DATE = '2025-07-11'
LOOKBACK_PERIOD = 5
EPOCHS = 10

"""### Download Data and Look at Raw Data"""

# Download Stock Data
Rawdata = yf.download(STOCK_SYMBOL, start=START_DATE, end=END_DATE)
print()
print(Rawdata.shape)
Rawdata

"""### Data PreProcessing: Reshape"""

# Reshape for compatibility with scaler
data = Rawdata['Close'].values.reshape(-1, 1)
data

"""### Data PreProcessing: Split into train-test"""

# Split the dataset into training and test sets
train_size = int(len(data) * 0.7)
data_train = data[:train_size]
data_test = data[train_size:]

print("Train:", data_train.shape)
print(data_train)
print("Test:", data_test.shape)
print(data_test)

"""### Data PreProcessing: Scaling Data"""

# Scale Data
scaler = MinMaxScaler(feature_range=(0, 1))

# Fit the scaler on the training data and transform both training and test data
scaler.fit(data_train)
data_train_scaled = scaler.transform(data_train)
data_test_scaled = scaler.transform(data_test)
# Printing for understanding
print("Scaled Train:", data_train_scaled.shape)
print(data_train_scaled)
print("Scaled Test:", data_test_scaled.shape)
print(data_test_scaled)

"""### Visualizing train-test on raw and scaled data"""

# Visualizing Data and Scaled Data side by side showing train-test split in time Series

# Create a figure with two subplots side by side
plt.figure(figsize=(30, 6))

# First subplot: Original Stock Price Data
plt.subplot(1, 2, 1)
plt.plot(np.arange(train_size), data_train, color="black", label="Training Data")
plt.plot(np.arange(train_size, len(data)), data_test, color="green", label="Test Data")
plt.title("Stock Price Data")
plt.xlabel("Time")
plt.ylabel("Price")
plt.legend()

# Second subplot: Scaled Stock Price Data
plt.subplot(1, 2, 2)
plt.plot(np.arange(train_size), data_train_scaled, color="black", label="Training Data")
plt.plot(np.arange(train_size, len(data)), data_test_scaled, color="green", label="Test Data")
plt.title("Scaled Stock Price Data")
plt.xlabel("Time")
plt.ylabel("Scaled Price")
plt.legend()

# Adjust layout and show the plots
plt.tight_layout()
plt.show()

"""### Prepare Training Data per Lookback Period"""

# Prepare training and test datasets
X_train, y_train = [], []

for i in range(len(data_train_scaled) - LOOKBACK_PERIOD - 1):
  X_train.append(data_train_scaled[i:(i + LOOKBACK_PERIOD), 0])
  y_train.append(data_train_scaled[i + LOOKBACK_PERIOD, 0])
# Convert to numpy arrays after appending elements
X_train, y_train = np.array(X_train), np.array(y_train)

"""Comparing training data vis-a-vis scaled data"""

# Print Scaled Data
print("Scaled Train Data \n", data_train_scaled)
#data_train_scaled.reshape(1, -1)

# X_Train on scaled data based on LOOKBACK_PERIOD
print("\n Lookback Period:",LOOKBACK_PERIOD)
print("\n X_train: \n",X_train.shape,"\n", X_train)
# y data
print("\n y_train: \n",y_train.shape,"\n", y_train)

"""### Prepare Test Data per Lookback Period"""

# Prepare test datasets
X_test, y_test = [], []

for i in range(len(data_test_scaled) - LOOKBACK_PERIOD - 1):
  X_test.append(data_test_scaled[i:(i + LOOKBACK_PERIOD), 0])
  y_test.append(data_test_scaled[i + LOOKBACK_PERIOD, 0])
# Convert to numpy arrays after appending elements
X_test, y_test = np.array(X_test), np.array(y_test)

"""Comparing testing dataset vis-a-vis scaled data

"""

# Comparing testing dataset vis-a-vis raw data

# Scaled Data
print("Scaled Test Data \n", data_test_scaled)
#data_test_scaled.reshape(1, -1)

# X_test on scaled data based on LOOKBACK_PERIOD
print("\n Lookback Period:",LOOKBACK_PERIOD)
print("\n X_test: \n",X_test.shape,"\n", X_test)
# y data
print("\n y_test : \n",y_test.shape,"\n", y_test)

"""### Initialize and Compile the Model

Defines a neural network model with three layers. The input layer has 64 neurons, the hidden layer has 32 neurons, and the output layer has 1 neuron. The model uses the mean squared error loss function and the Adam optimizer.
"""

# Initialize and compile the model
model = Sequential()
model.add(Dense(64, input_dim=LOOKBACK_PERIOD, activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')

"""### Train / Fit the Model"""

# Train the model
model.fit(X_train, y_train, epochs=EPOCHS, batch_size=1, verbose=1)

"""### Make Predictions on Train and Test"""

train_predict = model.predict(X_train)

test_predict = model.predict(X_test)

"""### Inverse transform the predictions to de-scale"""

# Inverse transform the predictions
train_predict = scaler.inverse_transform(train_predict)
y_train_original = scaler.inverse_transform(y_train.reshape(-1, 1))

test_predict = scaler.inverse_transform(test_predict)
y_test_original = scaler.inverse_transform(y_test.reshape(-1, 1))

"""Visualizing Predictions"""

# Subplot train_predict and y_train_original side by side
plt.figure(figsize=(10, 6))

plt.subplot(1, 2, 1)
plt.plot(y_train_original, label="Actual Train Data")
plt.plot(train_predict, label="Predicted Train Data")
plt.title("Train Data: Actual vs Predicted")
plt.xlabel("Time")
plt.ylabel("Stock Price")
plt.legend()

# Subplot test_predict and y_test_original
plt.subplot(1, 2, 2)
plt.plot(y_test_original, label="Actual Test Data")
plt.plot(test_predict, label="Predicted Test Data")
plt.title("Test Data: Actual vs Predicted")
plt.xlabel("Time")
plt.ylabel("Stock Price")
plt.legend()

plt.tight_layout()
plt.show()

"""### Evaluating Model Prediction Performance"""

# Calculate mean squared error
mse_train = mean_squared_error(y_train_original, train_predict)
print(f"Mean Squared Error on Train Data: {mse_train:.2f}")
mse_test = mean_squared_error(y_test_original, test_predict)
print(f"Mean Squared Error on Test Data: {mse_test:.2f}")

"""### Visualizing Output: TABULAR"""

# Calculate the difference for both train and test data
difference_train = y_train_original.ravel() - train_predict.ravel()
difference_test = y_test_original.ravel() - test_predict.ravel()


data1 = {'Date': Rawdata.index[-len(y_train_original):],
        'Actual': y_train_original.ravel(),
        'Predicted': train_predict.ravel(),
        'Difference': difference_train.ravel() }
df1 = pd.DataFrame(data1)

# Display the DataFrame
print(df1.to_string())

# Create a DataFrame (only for test data)
data = {'Date': Rawdata.index[-len(y_test_original):],
        'Actual': y_test_original.ravel(),
        'Predicted': test_predict.ravel(),
        'Difference': difference_test.ravel()}
df = pd.DataFrame(data)

# Display the DataFrame
print(df.to_string())

"""### Visualizing Predictions: Graphs"""

# Plot actual vs predicted prices
plt.figure(figsize=(15, 6))

# Combine actual price data from train and test
combined_actual = np.concatenate([y_train_original, y_test_original], axis=0)
#Combine predicted price data from train and test
combined_predicted = np.concatenate([train_predict, test_predict], axis=0)

# Plot difference between actual and predicted
difference = combined_actual.ravel() - combined_predicted.ravel()

# Plot in one Graph
plt.plot(combined_actual, label="Actual Prices", color="blue")
plt.plot(combined_predicted, label="Predicted Prices", color="red", alpha=0.7)
plt.axvline(x=len(y_train_original), color='black', linestyle='--', label='Train-Test Boundary')
plt.title("Combined Actual vs. Predicted Stock Prices")
plt.xlabel("Time")
plt.ylabel("Stock Price")
plt.legend(loc='upper left')
plt.grid(True)

# Plot the difference between actual and predicted prices
ax2 = plt.gca().twinx()
ax2.plot(difference, label="Difference", color="green", linestyle='--', alpha=0.7)
ax2.set_ylabel('Difference Between Actual and Predicted', color='green')
ax2.legend(loc='upper right')
ax2.tick_params(axis='y', labelcolor='green')

plt.show()

# Combining Graphs

# Plot actual vs predicted prices
plt.figure(figsize=(15, 6))

# Combine actual price data from train and test
combined_actual = np.concatenate([y_train_original, y_test_original], axis=0)
#Combine predicted price data from train and test
combined_predicted = np.concatenate([train_predict, test_predict], axis=0)

# Plot difference between actual and predicted
difference = combined_actual.ravel() - combined_predicted.ravel()

# Plot in one Graph
plt.plot(combined_actual, label="Actual Prices", color="blue")
plt.plot(combined_predicted, label="Predicted Prices", color="red", alpha=0.7)
plt.axvline(x=len(y_train_original), color='black', linestyle='--', label='Train-Test Boundary')
plt.title("Combined Actual vs. Predicted Stock Prices")
plt.xlabel("Time")
plt.ylabel("Stock Price")
plt.legend(loc='upper left')
plt.grid(True)

# Plot the difference between actual and predicted prices
ax2 = plt.gca().twinx()
ax2.plot(difference, label="Difference", color="green", linestyle='--', alpha=0.7)
ax2.set_ylabel('Difference Between Actual and Predicted', color='green')
ax2.legend(loc='upper right')
ax2.tick_params(axis='y', labelcolor='green')

plt.show()

"""### **Optional** Combining Graphs in Plotly"""

import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np

# Assume y_train_original, y_test_original, train_predict, test_predict are already defined

# Combine actual price data from train and test
combined_actual = np.concatenate([y_train_original, y_test_original], axis=0).ravel()
# Combine predicted price data from train and test
combined_predicted = np.concatenate([train_predict, test_predict], axis=0).ravel()
# Calculate the difference between actual and predicted prices
difference = combined_actual - combined_predicted

# Create a subplot with a secondary y-axis
fig = make_subplots(specs=[[{"secondary_y": True}]])

# Add traces for actual and predicted prices
fig.add_trace(
    go.Scatter(x=np.arange(len(combined_actual)), y=combined_actual, mode='lines', name='Actual Prices', line=dict(color='blue')),
    secondary_y=False,
)

fig.add_trace(
    go.Scatter(x=np.arange(len(combined_predicted)), y=combined_predicted, mode='lines', name='Predicted Prices', line=dict(color='red', dash='dash')),
    secondary_y=False,
)

# Add a vertical line to indicate the train-test boundary
fig.add_shape(
    dict(
        type="line",
        x0=len(y_train_original),
        y0=min(combined_actual),
        x1=len(y_train_original),
        y1=max(combined_actual),
        line=dict(color="black", width=2, dash="dash"),
    )
)

# Add a trace for the difference between actual and predicted prices
fig.add_trace(
    go.Scatter(x=np.arange(len(difference)), y=difference, mode='lines', name='Difference', line=dict(color='green', dash='dot')),
    secondary_y=True,
)

# Update layout for titles and labels
fig.update_layout(
    title="Combined Actual vs. Predicted Stock Prices",
    xaxis_title="Time",
    yaxis_title="Stock Price",
    yaxis2_title="Difference Between Actual and Predicted",
)

# Show the plot
fig.show()

"""# To Practice at Home
##TODO: 1. Try with another stock

##TODO: 2. Try with different time periods

##TODO: 3. Change ANN parameters
"""